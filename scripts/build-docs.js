const fs = require("fs");
const path = require("path");
const { marked } = require("marked");

const SECTION_HEADING = "## /Docs";
const SCRIPT_REL = "scripts/build-docs.js";

function resolveRoot() {
  const cwd = process.cwd();
  const fromRoot = path.join(cwd, "docs");
  if (fs.existsSync(path.join(cwd, "package.json")) && fs.existsSync(fromRoot))
    return cwd;

  const parent = path.resolve(cwd, "..");
  const fromParent = path.join(parent, "docs");
  if (
    fs.existsSync(path.join(parent, "package.json")) &&
    fs.existsSync(fromParent)
  )
    return parent;

  console.error("Could not locate project root with docs/ folder.");
  process.exit(1);
}

function extractTitle(filePath) {
  const src = fs.readFileSync(filePath, "utf-8");
  const tokens = marked.lexer(src);
  const h1 = tokens.find((t) => t.type === "heading" && t.depth === 1);
  if (h1) return h1.text;
  return path.basename(filePath, path.extname(filePath));
}

function collectDocs(dir, relBase) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const files = [];
  const subdirs = [];

  for (const e of entries) {
    if (e.name.startsWith(".")) continue;
    const full = path.join(dir, e.name);
    const rel = path.posix.join(relBase, e.name);
    if (e.isDirectory()) subdirs.push({ name: e.name, full, rel });
    else if (e.name.endsWith(".md")) files.push({ full, rel });
  }

  files.sort((a, b) => a.rel.localeCompare(b.rel));
  subdirs.sort((a, b) => a.name.localeCompare(b.name));

  const items = [];
  for (const f of files) {
    const title = extractTitle(f.full);
    items.push({ type: "file", title, rel: f.rel });
  }
  for (const d of subdirs) {
    const children = collectDocs(d.full, d.rel);
    if (children.length)
      items.push({ type: "dir", name: d.name, children });
  }
  return items;
}

function renderTree(items, indent) {
  const lines = [];
  for (const item of items) {
    if (item.type === "file") {
      lines.push(`${indent}- [${item.title}](${item.rel})`);
    } else {
      lines.push(`${indent}- /${item.name}`);
      lines.push(...renderTree(item.children, indent + "  "));
    }
  }
  return lines;
}

function buildSection(items) {
  const lines = [
    SECTION_HEADING,
    "",
    `> Auto-generated by [\`${SCRIPT_REL}\`](${SCRIPT_REL}). Do not edit manually.`,
    "",
  ];

  if (!items.length) {
    lines.push("_No documentation files found._");
  } else {
    lines.push(...renderTree(items, ""));
  }

  lines.push("");
  return lines.join("\n");
}

function inject(readmePath, section) {
  let content = fs.existsSync(readmePath)
    ? fs.readFileSync(readmePath, "utf-8")
    : "";

  const start = content.indexOf(SECTION_HEADING);
  if (start === -1) {
    const trimmed = content.trimEnd();
    fs.writeFileSync(
      readmePath,
      (trimmed ? trimmed + "\n\n" : "") + section,
      "utf-8",
    );
    return;
  }

  const afterStart = start + SECTION_HEADING.length;
  const nextH2 = content.indexOf("\n## ", afterStart);
  const before = content.slice(0, start).trimEnd();
  const after = nextH2 !== -1 ? content.slice(nextH2 + 1) : "";

  fs.writeFileSync(
    readmePath,
    (before ? before + "\n\n" : "") + section + (after ? "\n" + after : ""),
    "utf-8",
  );
}

const root = resolveRoot();
const docsDir = path.join(root, "docs");
const readmePath = path.join(root, "README.md");
const items = fs.existsSync(docsDir) ? collectDocs(docsDir, "docs") : [];
inject(readmePath, buildSection(items));
console.log("README.md /Docs section updated.");
